{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(address router) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/CircomExample.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport {MultiplierVerifier} from \"./verifiers/MultiplierVerifier.sol\";\nimport {SpendVerifier} from \"./verifiers/SpendVerifier.sol\";\nimport {OutputVerifier} from \"./verifiers/OutputVerifier.sol\";\n\nimport {MerkleTreeWithHistory} from \"./MerkleTreeWithHistory.sol\";\n\nimport \"./EdOnBN254.sol\";\n\ncontract CircomExample is MerkleTreeWithHistory {\n    using EdOnBN254 for *;\n\n    SpendVerifier public spendVerifier;\n    OutputVerifier public outputVerifier;\n\n    event NewCommitment(\n        uint256 indexed commitment,\n        uint256 indexed index,\n        bytes encryptedOutput\n    );\n\n    event NewNullifier(uint256 indexed nullifier);\n\n    mapping(uint256 => bool) public nullifierHashes;\n\n    struct SpendProof {\n        bytes proof;\n        uint256 nullifier;\n        uint[2] valueCommitment;\n    }\n\n    struct OutputProof {\n        bytes proof;\n        uint256 commitment;\n        uint[2] valueCommitment;\n        bytes encryptedOutput;\n    }\n\n    constructor(\n        address _spendVerifier,\n        address _outputVerifier,\n        address _hasher\n    ) MerkleTreeWithHistory(5, _hasher) {\n        spendVerifier = SpendVerifier(_spendVerifier);\n        outputVerifier = OutputVerifier(_outputVerifier);\n        _initialize();\n    }\n\n    function parseProof(\n        bytes memory data\n    )\n        internal\n        pure\n        returns (uint[2] memory a, uint[2][2] memory b, uint[2] memory c)\n    {\n        (a[0], a[1], b[0][0], b[0][1], b[1][0], b[1][1], c[0], c[1]) = abi\n            .decode(data, (uint, uint, uint, uint, uint, uint, uint, uint));\n    }\n\n    function spendVerify(\n        bytes memory _proof,\n        uint[1] memory _pubSignals\n    ) public view {\n        (uint[2] memory a, uint[2][2] memory b, uint[2] memory c) = parseProof(\n            _proof\n        );\n        require(\n            spendVerifier.verifyProof(a, b, c, _pubSignals),\n            \"invalid proof\"\n        );\n    }\n\n    function outputVerify(\n        bytes memory _proof,\n        uint[1] memory _pubSignals\n    ) public view {\n        (uint[2] memory a, uint[2][2] memory b, uint[2] memory c) = parseProof(\n            _proof\n        );\n        require(\n            outputVerifier.verifyProof(a, b, c, _pubSignals),\n            \"invalid proof\"\n        );\n    }\n\n    struct RedDSASignature {\n        bytes32 s;\n        bytes32 R;\n    }\n\n    function sigVerify(\n        uint256 _s,\n        uint256[2] memory _R,\n        uint256[2] memory _A,\n        bytes memory _message\n    ) public view {\n        EdOnBN254.Affine memory _Rp = EdOnBN254.Affine(_R[0], _R[1]);\n        EdOnBN254.Affine memory _Ap = EdOnBN254.Affine(_A[0], _A[1]);\n        bytes memory data = abi.encode(_Rp.x, _Rp.y, _Ap.x, _Ap.y, _message);\n\n        uint256 _c = uint256(keccak256(data)) % EdOnBN254.N;\n        EdOnBN254.Affine memory _Z = EdOnBN254\n            .primeSubgroupGenerator()\n            .neg()\n            .mul(_s)\n            .add(_Rp)\n            .add(_Ap.mul(_c));\n\n        require(_Z.x == 0, \"signature is not valid\");\n    }\n\n    function _transactCheck(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        EdOnBN254.Affine memory _valueBal,\n        uint256 _root\n    ) internal {\n        require(isKnownRoot(bytes32(_root)), \"Invalid merkle root\");\n\n        for (uint i = 0; i < _spendProof.length; i++) {\n            require(\n                !isSpent(_spendProof[i].nullifier),\n                \"Input is already spent\"\n            );\n        }\n\n        EdOnBN254.Affine memory total = EdOnBN254.zero();\n\n        for (uint i = 0; i < _spendProof.length; i++) {\n            SpendProof memory spendProof = _spendProof[i];\n            total = total.add(\n                EdOnBN254.Affine(\n                    spendProof.valueCommitment[0],\n                    spendProof.valueCommitment[1]\n                )\n            );\n        }\n\n        for (uint j = 0; j < _outputProofs.length; j++) {\n            OutputProof memory outputProof = _outputProofs[j];\n            total = total.add(\n                EdOnBN254\n                    .Affine(\n                        outputProof.valueCommitment[0],\n                        outputProof.valueCommitment[1]\n                    )\n                    .neg()\n            );\n        }\n\n        require(\n            total.add(_valueBal.neg()).x == _bpk[0] &&\n                total.add(_valueBal.neg()).y == _bpk[1],\n            \"Sum of values is incorrect\"\n        );\n\n        for (uint i = 0; i < _spendProof.length; i++) {\n            SpendProof memory spendProof = _spendProof[i];\n            spendVerify(spendProof.proof, [uint256(spendProof.nullifier)]);\n        }\n\n        for (uint j = 0; j < _outputProofs.length; j++) {\n            OutputProof memory outputProof = _outputProofs[j];\n            outputVerify(outputProof.proof, [uint256(outputProof.commitment)]);\n        }\n\n        for (uint i = 0; i < _spendProof.length; i++) {\n            nullifierHashes[_spendProof[i].nullifier] = true;\n        }\n\n        require(_outputProofs.length == 2, \"only can do 2 outputproofs\");\n\n        _insertCommitments(_outputProofs);\n        emit NewCommitment(\n            _outputProofs[0].commitment,\n            nextIndex - 2,\n            _outputProofs[0].encryptedOutput\n        );\n\n        emit NewCommitment(\n            _outputProofs[1].commitment,\n            nextIndex - 1,\n            _outputProofs[1].encryptedOutput\n        );\n\n        for (uint256 i = 0; i < _spendProof.length; i++) {\n            emit NewNullifier(_spendProof[i].nullifier);\n        }\n    }\n\n    function _insertCommitments(OutputProof[] memory _outputProofs) internal {\n        // Insert all leaves except the last one using pairs as usual\n        _insert(\n            bytes32(_outputProofs[0].commitment),\n            bytes32(_outputProofs[1].commitment)\n        );\n    }\n\n    function _deposit(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        uint256 _assetId,\n        uint256 _depositAmount,\n        uint256 _root\n    ) internal {\n        // this is the same as G * poseidon(asset) * value of asset being deposited\n        EdOnBN254.Affine memory _valueBal = EdOnBN254\n            .primeSubgroupGenerator()\n            .mul(_assetId)\n            .mul(_depositAmount)\n            .neg();\n\n        _transactCheck(_spendProof, _outputProofs, _bpk, _valueBal, _root);\n    }\n\n    function _withdraw(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        uint256 _assetId,\n        uint256 _withdrawAmount,\n        uint256 _root\n    ) internal {\n        // this is the same as G * poseidon(asset) * value of asset being deposited\n        EdOnBN254.Affine memory _valueBal = EdOnBN254\n            .primeSubgroupGenerator()\n            .mul(_assetId)\n            .mul(_withdrawAmount);\n\n        _transactCheck(_spendProof, _outputProofs, _bpk, _valueBal, _root);\n    }\n\n    function transact(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        uint256 _root\n    ) public {\n        EdOnBN254.Affine memory _valueBal = EdOnBN254.zero();\n\n        _transactCheck(_spendProof, _outputProofs, _bpk, _valueBal, _root);\n    }\n\n    function isSpent(uint256 _nullifierHash) public view returns (bool) {\n        return nullifierHashes[_nullifierHash];\n    }\n}\n"
    },
    "contracts/EdOnBN254.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\n// Courtesy https://github.com/Tetration-Lab/solidity-ed-on-bn254/blob/main/src/EdOnBN254V.sol\n\n// A Twisted Edwards curve on scalar field of BN254. Also known as [Baby-Jubjub](https://github.com/barryWhiteHat/baby_jubjub).\n// Modified from:\n// https://github.com/yondonfu/sol-baby-jubjub/blob/master/contracts/CurveBabyJubJub.sol\n// https://github.com/arkworks-rs/curves/tree/master/ed_on_bn254\n//\n// Curve information:\n// * Base field: q = 21888242871839275222246405745257275088548364400416034343698204186575808495617\n// * Scalar field: r = 2736030358979909402780800718157159386076813972158567259200215660948447373041\n// * Valuation(q - 1, 2) = 28\n// * Valuation(r - 1, 2) = 4\n// * Curve equation: ax^2 + y^2 =1 + dx^2y^2, where\n//    * a = 168700\n//    * d = 168696\nlibrary EdOnBN254 {\n    uint256 public constant Q =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 public constant E_A = 168700;\n    uint256 public constant E_D = 168696;\n    uint256 public constant N =\n        21888242871839275222246405745257275088614511777268538073601725287587578984328;\n    struct Affine {\n        uint256 x;\n        uint256 y;\n    }\n\n    function primeSubgroupGenerator() public pure returns (Affine memory) {\n        return\n            Affine(\n                995203441582195749578291179787384436505546430278305826713579947235728471134,\n                5472060717959818805561601436314318772137091100104008585924551046643952123905\n            );\n    }\n\n    function zero() public pure returns (Affine memory) {\n        return Affine(0, 1);\n    }\n\n    function add(\n        Affine memory a1,\n        Affine memory a2\n    ) public view returns (Affine memory) {\n        if (a1.x == 0 && a1.y == 0) {\n            return a2;\n        }\n\n        if (a2.x == 0 && a2.y == 0) {\n            return a1;\n        }\n\n        uint256 x1x2 = mulmod(a1.x, a2.x, Q);\n        uint256 y1y2 = mulmod(a1.y, a2.y, Q);\n        uint256 dx1x2y1y2 = mulmod(E_D, mulmod(x1x2, y1y2, Q), Q);\n        uint256 x3Num = addmod(mulmod(a1.x, a2.y, Q), mulmod(a1.y, a2.x, Q), Q);\n        uint256 y3Num = submod(y1y2, mulmod(E_A, x1x2, Q), Q);\n\n        return\n            Affine(\n                mulmod(x3Num, inverse(addmod(1, dx1x2y1y2, Q)), Q),\n                mulmod(y3Num, inverse(submod(1, dx1x2y1y2, Q)), Q)\n            );\n    }\n\n    function double(Affine memory a) public view returns (Affine memory) {\n        return add(a, a);\n    }\n\n    function mul(\n        Affine memory a,\n        uint256 s\n    ) public view returns (Affine memory) {\n        uint256 remaining = s;\n        Affine memory p = Affine(a.x, a.y);\n        Affine memory ret = Affine(0, 0);\n\n        while (remaining != 0) {\n            if ((remaining & 1) != 0) {\n                ret = add(ret, p);\n            }\n\n            p = double(p);\n\n            remaining = remaining / 2;\n        }\n\n        return ret;\n    }\n\n    function neg(Affine memory a) public pure returns (Affine memory) {\n        if (a.x == 0 && a.y == 0) return a;\n        return Affine(submod(0, a.x, Q), a.y);\n    }\n\n    function submod(\n        uint256 _a,\n        uint256 _b,\n        uint256 _mod\n    ) internal pure returns (uint256) {\n        return addmod(_a, _mod - _b, _mod);\n    }\n\n    function inverse(uint256 _a) internal view returns (uint256) {\n        return expmod(_a, Q - 2, Q);\n    }\n\n    function expmod(\n        uint256 _b,\n        uint256 _e,\n        uint256 _m\n    ) internal view returns (uint256 o) {\n        assembly {\n            let memPtr := mload(0x40)\n            mstore(memPtr, 0x20)\n            mstore(add(memPtr, 0x20), 0x20)\n            mstore(add(memPtr, 0x40), 0x20)\n            mstore(add(memPtr, 0x60), _b)\n            mstore(add(memPtr, 0x80), _e)\n            mstore(add(memPtr, 0xa0), _m)\n\n            let success := staticcall(gas(), 0x05, memPtr, 0xc0, memPtr, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                o := mload(memPtr)\n            }\n        }\n    }\n}\n"
    },
    "contracts/MerkleTreeWithHistory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IHasher {\n    function poseidon(\n        bytes32[2] calldata inputs\n    ) external pure returns (bytes32);\n}\n\ncontract MerkleTreeWithHistory {\n    uint256 public constant FIELD_SIZE =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    uint256 public constant ZERO_VALUE =\n        21663839004416932945382355908790599225266501822907911457504978515578255421292; // = keccak256(\"tornado\") % FIELD_SIZE\n\n    IHasher public hasher;\n    uint32 public immutable levels;\n\n    // the following variables are made public for easier testing and debugging and\n    // are not supposed to be accessed in regular code\n\n    // filledSubtrees and roots could be bytes32[size], but using mappings makes it cheaper because\n    // it removes index range check on every interaction\n    mapping(uint256 => bytes32) public filledSubtrees;\n    mapping(uint256 => bytes32) public roots;\n    uint32 public constant ROOT_HISTORY_SIZE = 100;\n    uint32 public currentRootIndex = 0; // todo remove\n    uint32 public nextIndex = 0;\n\n    constructor(\n        uint32 _levels,\n        address _hasher //        bytes memory _hasherBytecode\n    ) {\n        require(_levels > 0, \"_levels should be greater than zero\");\n        require(_levels < 32, \"_levels should be less than 32\");\n        levels = _levels;\n\n        hasher = IHasher(_hasher);\n    }\n\n    function _initialize() internal {\n        for (uint32 i = 0; i < levels; i++) {\n            filledSubtrees[i] = zeros(i);\n        }\n\n        roots[0] = zeros(levels);\n    }\n\n    /**\n      @dev Hash 2 tree leaves, returns Poseidon(_left, _right)\n    */\n    function hashLeftRight(\n        bytes32 _left,\n        bytes32 _right\n    ) public view returns (bytes32) {\n        require(\n            uint256(_left) < FIELD_SIZE,\n            \"_left should be inside the field\"\n        );\n        require(\n            uint256(_right) < FIELD_SIZE,\n            \"_right should be inside the field\"\n        );\n        bytes32[2] memory input;\n        input[0] = _left;\n        input[1] = _right;\n        return hasher.poseidon(input);\n    }\n\n    // Modified to insert pairs of leaves for better efficiency\n    function _insert(\n        bytes32 _leaf1,\n        bytes32 _leaf2\n    ) internal returns (uint32 index) {\n        uint32 _nextIndex = nextIndex;\n        require(\n            _nextIndex != uint32(2) ** levels,\n            \"Merkle tree is full. No more leaves can be added\"\n        );\n        uint32 currentIndex = _nextIndex / 2;\n        bytes32 currentLevelHash = hashLeftRight(_leaf1, _leaf2);\n        bytes32 left;\n        bytes32 right;\n\n        for (uint32 i = 1; i < levels; i++) {\n            if (currentIndex % 2 == 0) {\n                left = currentLevelHash;\n                right = zeros(i);\n                filledSubtrees[i] = currentLevelHash;\n            } else {\n                left = filledSubtrees[i];\n                right = currentLevelHash;\n            }\n            currentLevelHash = hashLeftRight(left, right);\n            currentIndex /= 2;\n        }\n\n        uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;\n        currentRootIndex = newRootIndex;\n        roots[newRootIndex] = currentLevelHash;\n        nextIndex = _nextIndex + 2;\n        return _nextIndex;\n    }\n\n    /**\n      @dev Whether the root is present in the root history\n    */\n    function isKnownRoot(bytes32 _root) public view returns (bool) {\n        if (_root == 0) {\n            return false;\n        }\n        uint32 _currentRootIndex = currentRootIndex;\n        uint32 i = _currentRootIndex;\n        do {\n            if (_root == roots[i]) {\n                return true;\n            }\n            if (i == 0) {\n                i = ROOT_HISTORY_SIZE;\n            }\n            i--;\n        } while (i != _currentRootIndex);\n        return false;\n    }\n\n    /**\n      @dev Returns the last root\n    */\n    function getLastRoot() public view returns (bytes32) {\n        return roots[currentRootIndex];\n    }\n\n    /// @dev provides Zero (Empty) elements for a MiMC MerkleTree. Up to 32 levels\n    // TODO: this should change to poseidon\n    function zeros(uint256 i) public pure returns (bytes32) {\n        if (i == 0)\n            return\n                bytes32(\n                    0x2fe54c60d3acabf3343a35b6eba15db4821b340f76e741e2249685ed4899af6c\n                );\n        else if (i == 1)\n            return\n                bytes32(\n                    0x13e37f2d6cb86c78ccc1788607c2b199788c6bb0a615a21f2e7a8e88384222f8\n                );\n        else if (i == 2)\n            return\n                bytes32(\n                    0x217126fa352c326896e8c2803eec8fd63ad50cf65edfef27a41a9e32dc622765\n                );\n        else if (i == 3)\n            return\n                bytes32(\n                    0x0e28a61a9b3e91007d5a9e3ada18e1b24d6d230c618388ee5df34cacd7397eee\n                );\n        else if (i == 4)\n            return\n                bytes32(\n                    0x27953447a6979839536badc5425ed15fadb0e292e9bc36f92f0aa5cfa5013587\n                );\n        else if (i == 5)\n            return\n                bytes32(\n                    0x194191edbfb91d10f6a7afd315f33095410c7801c47175c2df6dc2cce0e3affc\n                );\n        else if (i == 6)\n            return\n                bytes32(\n                    0x1733dece17d71190516dbaf1927936fa643dc7079fc0cc731de9d6845a47741f\n                );\n        else if (i == 7)\n            return\n                bytes32(\n                    0x267855a7dc75db39d81d17f95d0a7aa572bf5ae19f4db0e84221d2b2ef999219\n                );\n        else if (i == 8)\n            return\n                bytes32(\n                    0x1184e11836b4c36ad8238a340ecc0985eeba665327e33e9b0e3641027c27620d\n                );\n        else if (i == 9)\n            return\n                bytes32(\n                    0x0702ab83a135d7f55350ab1bfaa90babd8fc1d2b3e6a7215381a7b2213d6c5ce\n                );\n        else if (i == 10)\n            return\n                bytes32(\n                    0x2eecc0de814cfd8c57ce882babb2e30d1da56621aef7a47f3291cffeaec26ad7\n                );\n        else if (i == 11)\n            return\n                bytes32(\n                    0x280bc02145c155d5833585b6c7b08501055157dd30ce005319621dc462d33b47\n                );\n        else if (i == 12)\n            return\n                bytes32(\n                    0x045132221d1fa0a7f4aed8acd2cbec1e2189b7732ccb2ec272b9c60f0d5afc5b\n                );\n        else if (i == 13)\n            return\n                bytes32(\n                    0x27f427ccbf58a44b1270abbe4eda6ba53bd6ac4d88cf1e00a13c4371ce71d366\n                );\n        else if (i == 14)\n            return\n                bytes32(\n                    0x1617eaae5064f26e8f8a6493ae92bfded7fde71b65df1ca6d5dcec0df70b2cef\n                );\n        else if (i == 15)\n            return\n                bytes32(\n                    0x20c6b400d0ea1b15435703c31c31ee63ad7ba5c8da66cec2796feacea575abca\n                );\n        else if (i == 16)\n            return\n                bytes32(\n                    0x09589ddb438723f53a8e57bdada7c5f8ed67e8fece3889a73618732965645eec\n                );\n        else if (i == 17)\n            return\n                bytes32(\n                    0x0064b6a738a5ff537db7b220f3394f0ecbd35bfd355c5425dc1166bf3236079b\n                );\n        else if (i == 18)\n            return\n                bytes32(\n                    0x095de56281b1d5055e897c3574ff790d5ee81dbc5df784ad2d67795e557c9e9f\n                );\n        else if (i == 19)\n            return\n                bytes32(\n                    0x11cf2e2887aa21963a6ec14289183efe4d4c60f14ecd3d6fe0beebdf855a9b63\n                );\n        else if (i == 20)\n            return\n                bytes32(\n                    0x2b0f6fc0179fa65b6f73627c0e1e84c7374d2eaec44c9a48f2571393ea77bcbb\n                );\n        else if (i == 21)\n            return\n                bytes32(\n                    0x16fdb637c2abf9c0f988dbf2fd64258c46fb6a273d537b2cf1603ea460b13279\n                );\n        else if (i == 22)\n            return\n                bytes32(\n                    0x21bbd7e944f6124dad4c376df9cc12e7ca66e47dff703ff7cedb1a454edcf0ff\n                );\n        else if (i == 23)\n            return\n                bytes32(\n                    0x2784f8220b1c963e468f590f137baaa1625b3b92a27ad9b6e84eb0d3454d9962\n                );\n        else if (i == 24)\n            return\n                bytes32(\n                    0x16ace1a65b7534142f8cc1aad810b3d6a7a74ca905d9c275cb98ba57e509fc10\n                );\n        else if (i == 25)\n            return\n                bytes32(\n                    0x2328068c6a8c24265124debd8fe10d3f29f0665ea725a65e3638f6192a96a013\n                );\n        else if (i == 26)\n            return\n                bytes32(\n                    0x2ddb991be1f028022411b4c4d2c22043e5e751c120736f00adf54acab1c9ac14\n                );\n        else if (i == 27)\n            return\n                bytes32(\n                    0x0113798410eaeb95056a464f70521eb58377c0155f2fe518a5594d38cc209cc0\n                );\n        else if (i == 28)\n            return\n                bytes32(\n                    0x202d1ae61526f0d0d01ef80fb5d4055a7af45721024c2c24cffd6a3798f54d50\n                );\n        else if (i == 29)\n            return\n                bytes32(\n                    0x23ab323453748129f2765f79615022f5bebd6f4096a796300aab049a60b0f187\n                );\n        else if (i == 30)\n            return\n                bytes32(\n                    0x1f15585f8947e378bcf8bd918716799da909acdb944c57150b1eb4565fda8aa0\n                );\n        else if (i == 31)\n            return\n                bytes32(\n                    0x1eb064b21055ac6a350cf41eb30e4ce2cb19680217df3a243617c2838185ad06\n                );\n        else if (i == 32)\n            return\n                bytes32(\n                    0x25a90efc49af54a5b7154a6eaba978dcf04796b4984fe54be8d4ea8579e1f1e6\n                );\n        else revert(\"Index out of bounds\");\n    }\n}\n"
    },
    "contracts/RK.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./CircomExample.sol\";\n\ncontract RK is CircomExample, CCIPReceiver {\n    /// Chainlink CCIP Router Address - used to send messages across chains\n    IRouterClient public immutable router;\n\n    // hash of address + chain id to t/f to determine if this address is allowed to send\n    mapping(bytes32 => bool) allowedRemotes;\n\n    // list of allowed remote chain ids (used for receiving messages)\n    mapping(uint64 => bool) allowedChainIds;\n\n    // list of allowed destination chain ids (handy for UX)\n    mapping(uint64 chainId => bool enabled) private allowlistedChains;\n\n    // gas limit for CCIP message (TODO investigate more about this value)\n    uint256 gasLimit = 800_000;\n\n    // error and modifier used when sending to remote chain\n    error DestinationChainNotAllowlisted(uint64 destinationChainSelector);\n    modifier onlyAllowlistedDestinationChain(uint64 destinationChainSelector) {\n        if (!allowlistedChains[destinationChainSelector])\n            revert DestinationChainNotAllowlisted(destinationChainSelector);\n        _;\n    }\n\n    // checks to see if the contract sending a message from another network is allowed to send to this contract\n    modifier onlyAllowlistedSourceChain(\n        uint64 _sourceChainSelector,\n        address _sender\n    ) {\n        require(\n            allowedRemotes[\n                keccak256(abi.encode(_sender, _sourceChainSelector))\n            ],\n            \"Source Chain not allowed\"\n        );\n        _;\n    }\n\n    address owner;\n\n    constructor(\n        address _spendVerifier,\n        address _outputVerifier,\n        address _merkleHasher,\n        address _router,\n        address[] memory _allowlistedRemotes,\n        uint64[] memory _allowlistedChains\n    )\n        CircomExample(_spendVerifier, _outputVerifier, _merkleHasher)\n        CCIPReceiver(_router)\n    {\n        router = IRouterClient(_router);\n\n        // set all of our allowed remotes on chains\n        for (uint256 i = 0; i < _allowlistedChains.length; i++) {\n            allowedRemotes[\n                keccak256(\n                    abi.encode(_allowlistedRemotes[i], _allowlistedChains[i])\n                )\n            ] = true;\n        }\n\n        owner = msg.sender;\n    }\n\n    function _enforceOwner() internal view {\n        require(msg.sender == owner, \"Only owner can call this function\");\n    }\n\n    function allowlistChain(uint64 _chainId, bool _allowed) external {\n        _enforceOwner();\n        allowlistedChains[_chainId] = _allowed;\n    }\n\n    function updateAllowlistDestinationChain(\n        address _remoteAddress,\n        uint64 _chainId,\n        bool _allowed\n    ) external {\n        _enforceOwner();\n        allowedRemotes[\n            keccak256(abi.encode(_remoteAddress, _chainId))\n        ] = _allowed;\n    }\n\n    function updateGasLimit(uint256 _gasLimit) external {\n        _enforceOwner();\n        gasLimit = _gasLimit;\n    }\n\n    // logic called when this contract receives a message from another chain through the CCIP router\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage\n    )\n        internal\n        override\n        onlyAllowlistedSourceChain(\n            any2EvmMessage.sourceChainSelector,\n            abi.decode(any2EvmMessage.sender, (address))\n        )\n    {\n        // message received\n    }\n\n    struct SupportedAsset {\n        uint256 assetId;\n        address assetAddress;\n        uint8 decimals;\n    }\n\n    mapping(uint256 => SupportedAsset) public assetToAddress;\n\n    function addSupportedAsset(\n        uint256 _assetId,\n        address _assetAddress,\n        uint8 _decimals\n    ) external {\n        _enforceOwner();\n        assetToAddress[_assetId] = SupportedAsset(\n            _assetId,\n            _assetAddress,\n            _decimals\n        );\n    }\n\n    function deposit(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        uint256 _assetId,\n        uint256 _depositAmount,\n        uint256 _root\n    ) external {\n        // transfer the users asset to this address\n        SupportedAsset memory _asset = assetToAddress[_assetId];\n        require(_asset.assetAddress != address(0), \"Asset not supported\");\n\n        // transfer the asset to this contract\n        IERC20(_asset.assetAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _depositAmount\n        );\n\n        // call our deposit function (the proofs are verified in this function)\n        _deposit(\n            _spendProof,\n            _outputProofs,\n            _bpk,\n            _assetId,\n            _depositAmount,\n            _root\n        );\n    }\n\n    function withdraw(\n        SpendProof[] memory _spendProof,\n        OutputProof[] memory _outputProofs,\n        uint[2] memory _bpk,\n        uint256 _assetId,\n        uint256 _withdrawAmount,\n        uint256 _root\n    ) external {\n        SupportedAsset memory _asset = assetToAddress[_assetId];\n        require(_asset.assetAddress != address(0), \"Asset not supported\");\n\n        _withdraw(\n            _spendProof,\n            _outputProofs,\n            _bpk,\n            _assetId,\n            _withdrawAmount,\n            _root\n        );\n\n        // transfer the asset to this contract\n        IERC20(_asset.assetAddress).transfer(msg.sender, _withdrawAmount);\n    }\n}\n"
    },
    "contracts/verifiers/MultiplierVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\n// MultiplierVerifier\n\ncontract MultiplierVerifier {\n    // Scalar field size\n    uint256 constant r =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax =\n        20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay =\n        9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1 =\n        4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2 =\n        6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1 =\n        21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2 =\n        10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    uint256 constant IC0x =\n        6819801395408938350212900248749732364821477541620635511814266536599629892365;\n    uint256 constant IC0y =\n        9092252330033992554755034971584864587974280972948086568597554018278609861372;\n\n    uint256 constant IC1x =\n        17882351432929302592725330552407222299541667716607588771282887857165175611387;\n    uint256 constant IC1y =\n        18907419617206324833977586007131055763810739835484972981819026406579664278293;\n\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(\n        uint[2] calldata _pA,\n        uint[2][2] calldata _pB,\n        uint[2] calldata _pC,\n        uint[1] calldata _pubSignals\n    ) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(\n                    add(_pPairing, 32),\n                    mod(sub(q, calldataload(add(pA, 32))), q)\n                )\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(\n                    sub(gas(), 2000),\n                    8,\n                    _pPairing,\n                    768,\n                    _pPairing,\n                    0x20\n                )\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n\n            checkField(calldataload(add(_pubSignals, 0)))\n\n            checkField(calldataload(add(_pubSignals, 32)))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}\n"
    },
    "contracts/verifiers/OutputVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract OutputVerifier {\n    // Scalar field size\n    uint256 constant r =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax =\n        20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay =\n        9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1 =\n        4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2 =\n        6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1 =\n        21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2 =\n        10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    uint256 constant IC0x =\n        1683237225823114434475890574383752547954072352828691693424657766749909930157;\n    uint256 constant IC0y =\n        10110230595513512447464523409088479123880299917968738755747969449083376759640;\n\n    uint256 constant IC1x =\n        4056418060501632235230320772714212416570094334995124498323336691459959999359;\n    uint256 constant IC1y =\n        21643569436575009513875246258150055494694779099518902792361106450376709368816;\n\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(\n        uint[2] calldata _pA,\n        uint[2][2] calldata _pB,\n        uint[2] calldata _pC,\n        uint[1] calldata _pubSignals\n    ) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(\n                    add(_pPairing, 32),\n                    mod(sub(q, calldataload(add(pA, 32))), q)\n                )\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(\n                    sub(gas(), 2000),\n                    8,\n                    _pPairing,\n                    768,\n                    _pPairing,\n                    0x20\n                )\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n\n            checkField(calldataload(add(_pubSignals, 0)))\n\n            checkField(calldataload(add(_pubSignals, 32)))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}\n"
    },
    "contracts/verifiers/SpendVerifier.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n/*\n    Copyright 2021 0KIMS association.\n\n    This file is generated with [snarkJS](https://github.com/iden3/snarkjs).\n\n    snarkJS is a free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    snarkJS is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public\n    License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with snarkJS. If not, see <https://www.gnu.org/licenses/>.\n*/\n\npragma solidity >=0.7.0 <0.9.0;\n\ncontract SpendVerifier {\n    // Scalar field size\n    uint256 constant r =\n        21888242871839275222246405745257275088548364400416034343698204186575808495617;\n    // Base field size\n    uint256 constant q =\n        21888242871839275222246405745257275088696311157297823662689037894645226208583;\n\n    // Verification Key data\n    uint256 constant alphax =\n        20491192805390485299153009773594534940189261866228447918068658471970481763042;\n    uint256 constant alphay =\n        9383485363053290200918347156157836566562967994039712273449902621266178545958;\n    uint256 constant betax1 =\n        4252822878758300859123897981450591353533073413197771768651442665752259397132;\n    uint256 constant betax2 =\n        6375614351688725206403948262868962793625744043794305715222011528459656738731;\n    uint256 constant betay1 =\n        21847035105528745403288232691147584728191162732299865338377159692350059136679;\n    uint256 constant betay2 =\n        10505242626370262277552901082094356697409835680220590971873171140371331206856;\n    uint256 constant gammax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant gammax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant gammay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant gammay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n    uint256 constant deltax1 =\n        11559732032986387107991004021392285783925812861821192530917403151452391805634;\n    uint256 constant deltax2 =\n        10857046999023057135944570762232829481370756359578518086990519993285655852781;\n    uint256 constant deltay1 =\n        4082367875863433681332203403145435568316851327593401208105741076214120093531;\n    uint256 constant deltay2 =\n        8495653923123431417604973247489272438418190587263600148770280649306958101930;\n\n    uint256 constant IC0x =\n        21012000739560819142560423255928019433747389049417804685005853346299490572200;\n    uint256 constant IC0y =\n        3110505566226718760385739709087438592945845328831699463083576662218091229871;\n\n    uint256 constant IC1x =\n        19327189360385847724919098495693001434248018658209772205800586599839951879190;\n    uint256 constant IC1y =\n        14864085053986614968409113362162378348043653796760683469901851492790138603530;\n\n    // Memory data\n    uint16 constant pVk = 0;\n    uint16 constant pPairing = 128;\n\n    uint16 constant pLastMem = 896;\n\n    function verifyProof(\n        uint[2] calldata _pA,\n        uint[2][2] calldata _pB,\n        uint[2] calldata _pC,\n        uint[1] calldata _pubSignals\n    ) public view returns (bool) {\n        assembly {\n            function checkField(v) {\n                if iszero(lt(v, q)) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            // G1 function to multiply a G1 value(x,y) to value in an address\n            function g1_mulAccC(pR, x, y, s) {\n                let success\n                let mIn := mload(0x40)\n                mstore(mIn, x)\n                mstore(add(mIn, 32), y)\n                mstore(add(mIn, 64), s)\n\n                success := staticcall(sub(gas(), 2000), 7, mIn, 96, mIn, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n\n                mstore(add(mIn, 64), mload(pR))\n                mstore(add(mIn, 96), mload(add(pR, 32)))\n\n                success := staticcall(sub(gas(), 2000), 6, mIn, 128, pR, 64)\n\n                if iszero(success) {\n                    mstore(0, 0)\n                    return(0, 0x20)\n                }\n            }\n\n            function checkPairing(pA, pB, pC, pubSignals, pMem) -> isOk {\n                let _pPairing := add(pMem, pPairing)\n                let _pVk := add(pMem, pVk)\n\n                mstore(_pVk, IC0x)\n                mstore(add(_pVk, 32), IC0y)\n\n                // Compute the linear combination vk_x\n\n                g1_mulAccC(_pVk, IC1x, IC1y, calldataload(add(pubSignals, 0)))\n\n                // -A\n                mstore(_pPairing, calldataload(pA))\n                mstore(\n                    add(_pPairing, 32),\n                    mod(sub(q, calldataload(add(pA, 32))), q)\n                )\n\n                // B\n                mstore(add(_pPairing, 64), calldataload(pB))\n                mstore(add(_pPairing, 96), calldataload(add(pB, 32)))\n                mstore(add(_pPairing, 128), calldataload(add(pB, 64)))\n                mstore(add(_pPairing, 160), calldataload(add(pB, 96)))\n\n                // alpha1\n                mstore(add(_pPairing, 192), alphax)\n                mstore(add(_pPairing, 224), alphay)\n\n                // beta2\n                mstore(add(_pPairing, 256), betax1)\n                mstore(add(_pPairing, 288), betax2)\n                mstore(add(_pPairing, 320), betay1)\n                mstore(add(_pPairing, 352), betay2)\n\n                // vk_x\n                mstore(add(_pPairing, 384), mload(add(pMem, pVk)))\n                mstore(add(_pPairing, 416), mload(add(pMem, add(pVk, 32))))\n\n                // gamma2\n                mstore(add(_pPairing, 448), gammax1)\n                mstore(add(_pPairing, 480), gammax2)\n                mstore(add(_pPairing, 512), gammay1)\n                mstore(add(_pPairing, 544), gammay2)\n\n                // C\n                mstore(add(_pPairing, 576), calldataload(pC))\n                mstore(add(_pPairing, 608), calldataload(add(pC, 32)))\n\n                // delta2\n                mstore(add(_pPairing, 640), deltax1)\n                mstore(add(_pPairing, 672), deltax2)\n                mstore(add(_pPairing, 704), deltay1)\n                mstore(add(_pPairing, 736), deltay2)\n\n                let success := staticcall(\n                    sub(gas(), 2000),\n                    8,\n                    _pPairing,\n                    768,\n                    _pPairing,\n                    0x20\n                )\n\n                isOk := and(success, mload(_pPairing))\n            }\n\n            let pMem := mload(0x40)\n            mstore(0x40, add(pMem, pLastMem))\n\n            // Validate that all evaluations ∈ F\n\n            checkField(calldataload(add(_pubSignals, 0)))\n\n            checkField(calldataload(add(_pubSignals, 32)))\n\n            // Validate all evaluations\n            let isValid := checkPairing(_pA, _pB, _pC, _pubSignals, pMem)\n\n            mstore(0, isValid)\n            return(0, 0x20)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}